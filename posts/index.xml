<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on bschen</title>
    <link>http://bschen.tw/posts/</link>
    <description>Recent content in Posts on bschen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cmn-Hant</language>
    <lastBuildDate>Wed, 17 Jan 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://bschen.tw/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Add Xdebug to Alpine Linux Docker Container</title>
      <link>http://bschen.tw/posts/add-xdebug-to-alpine-linux-docker-container/</link>
      <pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://bschen.tw/posts/add-xdebug-to-alpine-linux-docker-container/</guid>
      <description>原本想在以 Docker 建立的 PHP container 裡加上 Xdebug，但是單純在 Dockerfile 裡下 pecl install xdebug 指令的話，會發生找不到 autoconf 套件的錯誤
所使用的 Docker image 是官方的 php:7.2.1-fpm-alpine3.7
透過網路搜尋到的資料，大概知道了要先把必須的套件裝上，才能把 Xdebug 加進 container 裡。而這些必須的套件其實在官方的 image 裡都有裝，只是官方的 image 在用完這些套件之後，就把這些套件刪除以節省空間了1
這也是 Alpine Linux 節省空間的小秘訣2：
$ apk add --virtual mypacks gcc vim $ apk del mypacks  1. 先把 $PHPIZE_DEPS 定義的套件裝上3 $ apk add --no-cache --virtual .build-deps $PHPIZE_DEPS  2. 安裝 Xdebug 因為 Xdebug 目前最新的 stable 版本 2.5.5 還不支援 PHP 7.2，所以要指定安裝為 beta 版4：</description>
    </item>
    
    <item>
      <title>Loading Classes without Namespace via Composer</title>
      <link>http://bschen.tw/posts/loading-classes-without-namespace-via-composer/</link>
      <pubDate>Sat, 28 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://bschen.tw/posts/loading-classes-without-namespace-via-composer/</guid>
      <description>沒有設定 namespace 或沒有依照 PSR-4 規範的 PHP class 檔案，依然可以透過 Composer 載入。以綠界的 SDK ECPay/ECPayAIO_PHP 為例，在 composer.json 中加入下列設定：
{ &amp;quot;autoload&amp;quot;: { &amp;quot;classmap&amp;quot;: [ &amp;quot;vendor/ECPay/ECPayAIO_PHP/AioSDK/sdk&amp;quot; ] }, &amp;quot;repositories&amp;quot;: [ { &amp;quot;type&amp;quot;: &amp;quot;package&amp;quot;, &amp;quot;package&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;ecpay/ecpayaio_php&amp;quot;, &amp;quot;version&amp;quot;: &amp;quot;dev-master&amp;quot;, &amp;quot;source&amp;quot;: { &amp;quot;url&amp;quot;: &amp;quot;git@github.com:ECPay/ECPayAIO_PHP.git&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;git&amp;quot;, &amp;quot;reference&amp;quot;: &amp;quot;dev-master&amp;quot; }, &amp;quot;dist&amp;quot;: { &amp;quot;url&amp;quot;: &amp;quot;https://github.com/ECPay/ECPayAIO_PHP/archive/master.zip&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;zip&amp;quot; } } } ] }  ⚠️ autoload.classmap 那裡，因為 vendor/ECPay/ECPayAIO_PHP/ApplePaySDK 和 vendor/ECPay/ECPayAIO_PHP/AioSDK 使用了相同的 method 名稱，又沒有設定 namespace。所以如果想把路徑設為 vendor/ECPay/ECPayAIO_PHP 一次載入所有的 class 的話，會因為 method 名稱重複產生衝突。把 ApplePaySDK 和 AioSDK 路徑分開列入 autoload.</description>
    </item>
    
    <item>
      <title>Edit crontab with Vim on macOS</title>
      <link>http://bschen.tw/posts/edit-crontab-with-vim-on-macos/</link>
      <pubDate>Thu, 16 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://bschen.tw/posts/edit-crontab-with-vim-on-macos/</guid>
      <description>在 macOS 上用 Vim 編輯 cron 時，除了會儲存失敗，還會收到下面的錯誤訊息：
 crontab: temp file must be edited in place
 一開始我以為是 Apple 不使用 crontab 而只用自家的 launchd。但看了文件之後發現 macOS 上的 crontab 並沒有被廢棄，我才把矛頭指向 Vim
找解法找了很久，最後才靠著某篇回答，在 .vimrc 裡加上一列設定處理掉這個狀況：
set nowritebackup  2017-10-24 edit: 事隔一年多後，又在網路上看到有人也踩到一樣的問題1
不同的是，對方找到的解法跟我找到的解法不太一樣。對方所找到的文章裡2所給的解法是：
autocmd filetype crontab setlocal nobackup nowritebackup  這個方式感覺比較靈活，也不錯
 https://www.facebook.com/othree/posts/10156040898604208 ↩ http://vim.wikia.com/wiki/Editing_crontab ↩   </description>
    </item>
    
    <item>
      <title>An AES Encryption Implementation in PHP</title>
      <link>http://bschen.tw/posts/an-aes-encryption-implementation-in-php/</link>
      <pubDate>Wed, 01 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://bschen.tw/posts/an-aes-encryption-implementation-in-php/</guid>
      <description>雖然網路上找到的大部份程式碼都是用 Mcrypt 模組實作的範例，不過用 OpenSSL 模組來實作的話會更簡潔明瞭：
 用 Mcrypt 實作的範例：
 實作時還發生了一個小烏龍：由於跟別人事先約定好要用 AES 128 加密，可是共用的密鑰長度卻是 32 個字元（256 bits），讓我在用 AES-128-CBC 測試時一直沒辦法解密出正確的原文，之後心血來潮改用 AES-256-CBC 測試後就成功解密了。找資料時看到別人遇到的類似狀況，我才確定問題出在密鑰的長度上
 Encrypt and decrypt strings in PHP | Urban Insight Using openssl_en/decrypt() in PHP instead of&amp;hellip; initialisation vector - Encrypting using AES-256, can I use 256 bits IV? - Information Security Stack Exchange 寫程式是良心事業: Python M2Crypto - AES 的 Encrypt 與 Decrypt  </description>
    </item>
    
    <item>
      <title>ISO Week Date: A Case Study of Twitter Down</title>
      <link>http://bschen.tw/posts/iso-week-date-a-case-study-of-twitter-down/</link>
      <pubDate>Mon, 29 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://bschen.tw/posts/iso-week-date-a-case-study-of-twitter-down/</guid>
      <description>由於本週四就是 2015 年的元旦了，所以用 ISO week date 記錄時間的系統，會從週一開始進入 2015 年，即使週一的日期是 2014-12-29 才對
摘自 Wikipedia 的說明：
 The first week of the year, hence, always contains 4 January. ISO week year numbering therefore slightly deviates from the Gregorian for some days close to 1 January.
 關於 PHP date(&#39;o&#39;) 的說明：
 ISO-8601 year number. This has the same value as Y, except that if the ISO week number (W) belongs to the previous or next year, that year is used instead.</description>
    </item>
    
    <item>
      <title>XSS Case Study</title>
      <link>http://bschen.tw/posts/xss-case-study/</link>
      <pubDate>Fri, 27 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://bschen.tw/posts/xss-case-study/</guid>
      <description>Prologue 在此對我於某公司經手過的攻擊案例做一份概略的整理報告。以下列出的攻擊方式不一定會單獨出現，多半都是混合使用
Cases URL Encoded Attack 攻擊者向使用者發送一段訊息，訊息裡夾帶一段類似網址的字串：www&amp;amp;#46really-bad&amp;amp;#46com
當使用者讀取到這段訊息，&amp;amp;#46 被瀏覽器解碼變成 . 之後，顯示出來的就會是 www.really-bad.com 這樣完整的網址
其中還有一種變體是針對 RFC 3490 的實作所進行的攻擊方式：
 Whenever dots are used as label separators, the following characters MUST be recognized as dots: U+002E (full stop), U+3002 (ideographic full stop), U+FF0E (fullwidth full stop), U+FF61 (halfwidth ideographic full stop).
 在網址中插入能被轉換為 . 的字元，例如 www。really-bad。com，這樣也會被瀏覽器解碼為有效的網址：www.really-bad.com
Deceptive Phishing 攻擊者向使用者發送一段訊息，內容含有與某公司網址極為相似的假網址：
 您好，我已經下標了，麻煩確認一下這款是否還有現貨？
http://shops.com.tw/item/xxxxx
最好可以一起合併結帳，過兩天就去匯款，請核對謝謝！
 其中 shops.com.tw 並不是屬於某公司的網址，正確的網址應該是 shop.com.tw 才對
而使用者點擊假網址之後，就會被重新導向到攻擊者仿造的某公司登入頁面。就算使用者主動檢查登入頁面的網址，也只會看到像是 http://account.shops.com.tw/login 這樣，與真正的登入網址極為相似的假網址</description>
    </item>
    
  </channel>
</rss>